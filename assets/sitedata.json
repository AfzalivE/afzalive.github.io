


{
  "pages": [
    {
      
      
      
      "content": "\n",
      "url": "/404.html"
    },{
      
      "title": "Awake for Debug",
      
      "content": "Privacy Policy\n\nAfzal Najam built the Awake for Debug app as an Open Source app. This SERVICE is provided by Afzal Najam at no cost and is intended for use as is.\n\nThis page is used to inform visitors regarding my policies with the collection, use, and disclosure of Personal Information if anyone decided to use my Service.\n\nIf you choose to use my Service, then you agree to the collection and use of information in relation to this policy. There is no Personal Information that I collect.\n\nThe terms used in this Privacy Policy have the same meanings as in our Terms and Conditions, which is accessible at Awake for Debug unless otherwise defined in this Privacy Policy.\n\nInformation Collection and Use\n\nThere is no information collected and transmitted anywhere from this app.\n\nLog Data\n\nThere is no data logged from this app.\n\nService Providers\n\nI may employ third-party companies and individuals due to the following reasons:\n\n\n  To facilitate our Service;\n  To provide the Service on our behalf;\n  To perform Service-related services; or\n  To assist us in analyzing how our Service is used.\n\n\nI want to inform users of this Service that these third parties have access to your Personal Information. The reason is to perform the tasks assigned to them on our behalf. However, they are obligated not to disclose or use the information for any other purpose.\n\nSecurity\n\nWe don’t collect any information from this app, so we don’t need to secure anything.\n\nLinks to Other Sites\n\nThis Service may contain links to other sites. If you click on a third-party link, you will be directed to that site. Note that these external sites are not operated by me. Therefore, I strongly advise you to review the Privacy Policy of these websites. I have no control over and assume no responsibility for the content, privacy policies, or practices of any third-party sites or services.\n\nChildren’s Privacy\n\nThese Services do not address anyone under the age of 13. I do not knowingly collect personally identifiable information from children under 13. In the case I discover that a child under 13 has provided me with personal information, I immediately delete this from our servers. If you are a parent or guardian and you are aware that your child has provided us with personal information, please contact me so that I will be able to do necessary actions.\n\nChanges to This Privacy Policy\n\nI may update our Privacy Policy from time to time. Thus, you are advised to review this page periodically for any changes. I will notify you of any changes by posting the new Privacy Policy on this page. These changes are effective immediately after they are posted on this page.\n\nContact Us\n\nIf you have any questions or suggestions about my Privacy Policy, do not hesitate to contact me.\n\nThis privacy policy page was created at privacypolicytemplate.net and modified/generated by App Privacy Policy Generator\n",
      "url": "/other/AwakeDebug_privacy_policy/"
    },{
      
      "title": "InAppPurchases",
      
      "content": "Privacy Policy\n\nAfzal Najam built the InAppPurchases app as an Open Source app. This SERVICE is provided by Afzal Najam at no cost and is intended for use as is.\n\nThis page is used to inform visitors regarding my policies with the collection, use, and disclosure of Personal Information if anyone decided to use my Service.\n\nIf you choose to use my Service, then you agree to the collection and use of information in relation to this policy. There is no Personal Information that I collect.\n\nThe terms used in this Privacy Policy have the same meanings as in our Terms and Conditions, which is accessible at InAppPurchases unless otherwise defined in this Privacy Policy.\n\nInformation Collection and Use\n\nThere is no information collected and transmitted anywhere from this app.\n\nLog Data\n\nThere is no data logged from this app.\n\nService Providers\n\nI may employ third-party companies and individuals due to the following reasons:\n\n\n  To facilitate our Service;\n  To provide the Service on our behalf;\n  To perform Service-related services; or\n  To assist us in analyzing how our Service is used.\n\n\nI want to inform users of this Service that these third parties have access to your Personal Information. The reason is to perform the tasks assigned to them on our behalf. However, they are obligated not to disclose or use the information for any other purpose.\n\nSecurity\n\nWe don’t collect any information from this app, so we don’t need to secure anything.\n\nLinks to Other Sites\n\nThis Service may contain links to other sites. If you click on a third-party link, you will be directed to that site. Note that these external sites are not operated by me. Therefore, I strongly advise you to review the Privacy Policy of these websites. I have no control over and assume no responsibility for the content, privacy policies, or practices of any third-party sites or services.\n\nChildren’s Privacy\n\nThese Services do not address anyone under the age of 13. I do not knowingly collect personally identifiable information from children under 13. In the case I discover that a child under 13 has provided me with personal information, I immediately delete this from our servers. If you are a parent or guardian and you are aware that your child has provided us with personal information, please contact me so that I will be able to do necessary actions.\n\nChanges to This Privacy Policy\n\nI may update our Privacy Policy from time to time. Thus, you are advised to review this page periodically for any changes. I will notify you of any changes by posting the new Privacy Policy on this page. These changes are effective immediately after they are posted on this page.\n\nContact Us\n\nIf you have any questions or suggestions about my Privacy Policy, do not hesitate to contact me.\n\nThis privacy policy page was created at privacypolicytemplate.net and modified/generated by App Privacy Policy Generator\n",
      "url": "/other/InAppPurchases_privacy_policy/"
    },{
      
      "title": "Hi there! I'm Afzal Najam.",
      
      "content": "I’m an Android developer who loves basketball. I currently work at Doist, on the Todoist and Twist apps. I live in Toronto, Canada. You can reach me through these platforms.\n\nI like building mobile applications and I love contributing to open source software in my spare time. Some of the projects I’ve contributed to in the past include:\n\n\n  Mozilla Firefox on Android\n  Spyder IDE\n  Android Open Source Project.\n\n\nContact info\n\n  Email: hello@afzaln.com\n  Twitter: @afzalive\n  GitHub: @afzalive\n  LinkedIn: @afzalive\n  You can also ask any questions about this website or the content through GitHub issues.\n\n",
      "url": "/about/"
    },{
      
      "title": "Home",
      
      "content": "\n",
      "url": "/"
    },{
      
      
      
      "content": "\n",
      "url": "/offline.html"
    },{
      
      "title": "Posts",
      "description": "This is the list layout for showing blog posts, which shows just the title and groups them by year of publication. Check out the blog layout for comparison.\n",
      "content": "\n",
      "url": "/posts/"
    },{
      
      "title": "Projects",
      "description": "How people are using Hydejack in the real world.  This page is built using the projects layout* that you can use yourself to build a portfolio.\n",
      "content": "If you’d like to have your blog or project featured here, please contact me at mail@qwtel.com.\n\n\n",
      "url": "/projects/"
    },{
      
      "title": "Résumé*",
      "description": "This is the description of your resume page, as it will be seen by search engines. You’ll probably want to modify it in resume.md, and maybe set hide_description to true in the front matter.\n",
      "content": "\n",
      "url": "/resume/"
    }
  ], 
  "documents": [
    {
      
      "title": "Diving into Android Studio source code",
      "date": "2017-10-11 00:11:40 +0000",
      
      "content": "\n  This article was originally written in March 2017. Since then, the issue in question has been fixed, at least as of Android Studio 3.1 Preview 8. Although, the solution proposed in this article was not used, this write-up has proven itself useful for when I want to build Android Studio.\n\n\nIt all began with me being annoyed enough at a bug to think “I should do something more than just file another issue,” and so I cloned the Android Studio code, using instructions from http://tools.android.com/build/studio.\n\nThe actual problem\n\nThe issue we’re investigating today is, from what I recall, a recent regression. For a custom view that extends a layout and the tools:parentTag attribute getChildAt(0) is present in the merge layout XML, if you call In the constructor, the preview panel complains that that element is a LinearLayout and it cannot be cast to, say, TextView. However, it works perfectly at runtime.\n\n\n  The bug in question.\n\n\nCloning the repo\n\nTo check out the latest of Android Studio, simply type in these commands.\n\n$ mkdir studio-master-dev\n$ cd studio-master-dev\n$ repo init -u https://android.googlesource.com/platform/manifest -b studio-master-dev\n$ repo sync\n\n\nThe setup\n\nI wanted to troubleshoot an issue in the Preview panel so I had to build Android Studio. To do this, I opened the tools/idea folder in IDEA. This folder contains pretty much everything Android-related you see while using Android Studio. Plugins, actions, layout previews, menu items, the Android project view, all the panels, etc.\n\nThe IDE will take its sweet time indexing and setting up the project, it took 7 minutes for me.\n\nNow, building Android Studio is quite different from building an Android app. Thankfully, though, since Android tools are mostly Java and Groovy-based, we can use IntelliJ IDEA to build them.\n\nNote: Even though the guide says “use JDK 1.6”, I found that ConstraintSolver code had Lambdas and some parts of the code used Diamonds, so obviously, we needed JDK 1.8 for some things. Thanks to Nicolas Roard’s confirmation (ConstraintLayout team), “you should indeed use JDK 1.8.” So switch the Project SDK to JDK 1.8 and rename it to “IDEA jdk” (very important!).\n\nHit the Build button, you might come across some Kotlin errors about not being able to reassign a final val, I changed those to var. Build again, and run, and finally, there’s that little Android Studio debug build that we were looking for!\n\nIf you get an error like “Could not find IDEA jdk (or JDK 1.8) for module xyz, go to the Project Structure &gt; Modules. Find the module xyz and reorder its dependencies so that “IDEA jdk” is at the top.\n\nReproducing the bug\n\nTime to create a test project. Oh hold on, what’s that? The debug build doesn’t contain an embedded JDK, so Android Studio is unable to find one. Turns out, it’s an easy temporary fix.\n\n\n  Just comment out lines 431–435 in IdeSdks.java. Run it again, and bam! Android Studio is able to find the external JDK and project opens up without an issue.\n  \n    Now, go to Module Settings (right-click module), and change the Project SDK to Android SDK. Re-open the project so Gradle can sync and everything is good in the world again. Thankfully, we don’t have to do this every time we run a build.\n  \n  Back to the actual problem. Let’s create our custom view, TestView. Simple LinearLayout subclass.\n\n\npublic class TestView extends LinearLayout {\n    public TestView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        LayoutInflater.from(context).inflate(R.layout.view_test, this, true);\n\n        TextView tv = (TextView) getChildAt(0);\n        tv.setText(\"Hi\");\n    }\n}\n\n\n4. Inflate a merge XML layout in the constructor, with a TextView as the first child in the layout.\n\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:parentTag=\"LinearLayout\"&gt;\n\n    &lt;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hi\"/&gt;\n\n    &lt;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello\"/&gt;\n\n&lt;/merge&gt;\n\n\n5. Alright, let’s build the project. Take a moment to appreciate that we’re building a project, inside an IDE that we just built. Then put this view in our activity_main.xml, and finally, let’s preview it.\n\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/activity_main\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n    android:paddingRight=\"@dimen/activity_horizontal_margin\"\n    android:paddingTop=\"@dimen/activity_vertical_margin\"\n    android:paddingBottom=\"@dimen/activity_vertical_margin\"\n    android:orientation=\"vertical\"\n    tools:context=\"com.afzaln.issueonetest.MainActivity\"&gt;\n\n    &lt;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\" /&gt;\n\n    &lt;com.afzaln.issueonetest.TestView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"/&gt;\n&lt;/LinearLayout&gt;\n\n\nAs expected, there’s the error. Let’s pull up the exception using “Show Exception” and see what we’re dealing with.\n\njava.lang.ClassCastException: android.widget.LinearLayout cannot be cast to android.widget.TextView\n at com.afzaln.issueonetest.TestView.&lt;init&gt;(TestView.java:19)\n at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n at java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n at org.jetbrains.android.uipreview.ViewLoader.createNewInstance(ViewLoader.java:465)\n at org.jetbrains.android.uipreview.ViewLoader.loadClass(ViewLoader.java:172)\n at org.jetbrains.android.uipreview.ViewLoader.loadView(ViewLoader.java:105)\n at com.android.tools.idea.rendering.LayoutlibCallbackImpl.loadView(LayoutlibCallbackImpl.java:186)\n at android.view.BridgeInflater.loadCustomView(BridgeInflater.java:334)\n at android.view.BridgeInflater.loadCustomView(BridgeInflater.java:345)\n at android.view.BridgeInflater.createViewFromTag(BridgeInflater.java:245)\n at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:727)...\n\n\nLooks exactly like I thought. The preview hierarchy suggests that LinearLayout is a child of our custom view, TestView, which is not the case in reality. So a workaround would be to just use getChildAt(0).getChildAt(0). That, however, fails at runtime because that’s not the real hierarchy in the compiled app, also our “fixed” preview is slightly wrong, it’s using the merge tag’s orientation attribute. So what’s really happening?\n\nWhat’s happening is that the tools:parentTag attribute is being used even in activity_main.xml when it should not be the case. If we remove this tag, preview works just as expected.\n\nFinding the culprit\n\nWell, it seems like the fix is simple. If we’re inflating a custom view which is a child of the current view, don’t use the tools:parentTag attribute. Basically, only use that attribute when inflating the preview for merge layout XML.\n\nIn practice, this proved to be not so straight-forward. You see, what happens is that Android Studio this class called RenderTask to tell the layoutlib package how to inflate the\nlayout. This includes passing it a custom LayoutLibCallback instance which contains an implementation of an ILayoutPullParser. This implementation is obtained from the LayoutPullParserFactory.create() method, based on what type of resource we’re dealing with. Is it a Layout, Drawable, Menu, or raw XML?\n\nIn our case, it’s a Layout, so that means we get an instance of the LayoutPsiPullParser class, specifically the constructor at line 134. From here, we see that Android Studio calls the static createSnapshot() method so we follow it there. Here is the code which decides different tags in the XML layout. Going down this hole, we finally figure out the part where the IDE decides what to do with the parentTag attribute, in LayoutPsiPullParser:683, which is\nthe static createSnapshotForMerge() method.\n\nThis method basically says: If there’s a tools:parentTag attribute, create a “Synthetic tag” with for this XML tag, so that later on, layoutlib treats it as if it were the specified “parentTag” instead of the merge tag, and that is how we got the much-demanded parentTag feature, which is a very useful feature, might I add.\n\nAt this point, it doesn’t seem that simple to figure whether this XML tag is the root tag in the layout or if it’s coming from being included in another layout. Upon inspection of the rootTag object, it looks pretty identical in both cases.\n\nHowever, I can obviously confirm that making the parentTag variable null gets rid of both, this whole issue, and the feature. We don’t want to do that.\n\nThis post is already getting longer than I hoped, and most of it is about investigating the code instead of the actual bug fix, so bug fix will have to come in Part 2.\n",
      "categories": [],
      "tags": ["android","android-studio"],
      
      "collection": "posts",
      "url": "/diving-into-android-studio-source-code/"
    },{
      "image": "https://cdn-images-1.medium.com/max/1800/1*q91Kf2ywYM092vW0_VzYnA.png",
      "title": "Switching from RoboGuice to Dagger 2",
      "date": "2018-04-21 00:11:40 +0000",
      
      "content": "Recently, we decided that we wanted to let go of a deprecated, unmaintained RoboGuice and move to Dagger 2. There were two main reasons for this:\n\n\n  Better performance, since Dagger doesn’t use runtime reflection,\n  Method count, since RoboGuice adds about 10,000 methods\n\n\nImport ButterKnife and Dagger 2\n\nFirst things first, I removed RoboGuice from build.gradle and added ButterKnife and Dagger 2.12\n\n\n  build.gradle\n\n      implementation \"com.google.dagger:dagger:2.12\"\n    annotationProcessor \"com.google.dagger:dagger-compiler:2.12\"\n\n    implementation \"com.jakewharton:butterknife:8.8.1\"\n    annotationProcessor \"com.jakewharton:butterknife-compiler:8.8.1\"\n  \n\n\n@InjectView\n\nWe used RoboGuice’s InjectView a lot, so we had to do something about that, we decided to go with ButterKnife. It was pretty simple. Three steps:\n\n\n  Use “Replace in Path” to replace all instances of @InjectView with @BindView\n  A simple regexp to remove private from all those fields since ButterKnife doesn’t allow private fields\n  Replace import roboguice.inject.InjectView; with import butterknife.BindView;\n  In every Activity and Fragment, call ButterKnife.bind(this) (in onCreate) or ButterKnife.bind(this, view) (in onCreateView)\n  Remove all RoboGuice injector calls in those classes.\n\n\nGoogle annotations to javax annotations\n\nAgain, simple stuff, just a matter of replacing the imports. Replace in Path, find import com.google.inject. and replace with import javax.inject.\n\nThe grunt work\n\nNow lets build our object graph. With RoboGuice, we had an AppModule.java file that extended AbstractModule and overrode its configure() method. In it, we bound each interface with it’s implementation depending on the flags set in the app. This isn’t how Dagger does it so I made two new files:\n\n\n  AppModule\n  AppComponent\n\n\nIn the AppModule, I first wrote a constructor that took Context, so that I can provide that to all classes that depend on it.\n\n\n  AppModule.java\n\n  @Module\npublic class AppModule {\n   private Context appContext;\n\n   public AppModule(Context context) {\n       this.appContext = context.getApplicationContext();\n   }\n\n   @Provides\n   Context context() {\n       return appContext;\n   }\n  \n\n\nHere’s how we provide an instance of a hypothetical ApiService implementation, which depends on a PreferenceHelper class.\n\n\n  AppModule.java\n\n     @Provides\n   ApiService apiService(ApiServiceImpl impl) {\n   \treturn impl;\n   }\n  \n\n\nTurns out that this is the right way to use Dagger to provide an implementation. Where’s the constructor call? In the generated code! Here’s the class definition for ApiService.\n\n\n  ApiService.java\n\n  public abstract class ApiService {\n\n    public ApiService(PreferenceHelper preferenceHelper) {\n        this.preferenceHelper = preferenceHelper;\n    }\n}\n  \n\n\nThere’s no @Inject on this constructor since this is an abstract class. This is ApiServiceImpl. This is where the magic happens.\n\n\n  ApiServiceImpl.java\n\n  @Singleton\npublic class ApiServiceImpl extends ApiService {\n\n     @Inject\n     public ApiServiceImpl(PreferenceHelper preferenceHelper) {\n       super(preferenceHelper);\n     }\n}\n  \n\n\nTo provide an instance of PreferenceHelper, Dagger figures out where to get it and then calls the constructor. Here’s the generated factory class:\n\n\n  ApiServiceImpl_Factory.java\n\n  public final class ApiServiceImpl_Factory implements Factory&lt;ApiServiceImpl&gt; {\n  private final Provider&lt;PreferenceHelper&gt; preferenceHelperProvider;\n\n  public ApiServiceImpl_Factory(Provider&lt;PreferenceHelper&gt; preferenceHelperProvider) {\n    this.preferenceHelperProvider = preferenceHelperProvider;\n  }\n\n  @Override\n  public ApiServiceImpl get() {\n    return new ApiServiceImpl(preferenceHelperProvider.get());\n  }\n\n  public static Factory&lt;ApiServiceImpl&gt; create(\n      Provider&lt;PreferenceHelper&gt; preferenceHelperProvider) {\n    return new ApiServiceImpl_Factory(preferenceHelperProvider);\n  }\n}\n  \n\n\nAnd PreferenceHelper is just a simple class with a @Singleton annotation up top and an empty constructor with @Inject annotation so Dagger knows this is a dependency to provide and its scope is Singleton.\n\nNow, most of our provided classes used field injection instead of constructor injection, which doesn’t play as nicely with Dagger so I had to write those new constructors and field assignments by hand but aside from that, didn’t have to worry about where those dependencies came from. Eventually, my AppModule.class looked a lot like this:\n\n\n  AppModule.java\n\n  @Module\npublic class AppModule {\n   private Context appContext;\n\n   public AppModule(Context context) {\n      this.appContext = context.getApplicationContext();\n   }\n\n   @Provides\n   Context context() {\n      return appContext;\n   }\n\n   @Provides\n   ApiService apiService(ApiServiceImpl impl) {\n      return impl;\n   }\n\n   @Provides\n   Service1 service1(Service1Impl impl) {\n      return impl;\n   }\n\n   @Provides\n   Service2 service2(Service2Impl impl) {\n      return impl;\n   }\n\n   // A few other services ...\n}\n  \n\n\nNow that’s done. Dependencies that didn’t have to extend an abstract class or interface simply used @Inject in their constructor and Dagger provided them. On to AppComponent.java\n\n\n  AppComponent.java\n\n  @Singleton\n@Component(modules = {AppModule.class})\npublic interface AppComponent {\n  void inject(MyApp app);\n  void inject(MainActivity activity);\n  // Other activities, fragments, Broadcast Receivers, and Android Services\n}\n  \n\n\nWe have some @Inject calls in our Application class (probably should clean that up now) so we call inject(this) in it, and also all activities, fragments, and Android services. Basically, wherever we can’t use constructor injection.\n\nAlmost there\n\nTime to build the app so Dagger can generate all the code using its annotation processor. And finally, use that code in the custom Application class.\n\n\n  MyApp.java\n\n  public class MyApp extends Application {\n   private static MyApp application;\n\n   @Inject\n   SomeDependency dependency;\n\n   @Override\n   public void onCreate() {\n       super.onCreate();\n       getAppComponent().inject(this);\n   }\n\n   public static NortonApplication getApplication&gt;() {\n       return application;\n   }\n\n   public void createAppComponent() {\n       appComponent = DaggerAppComponent.builder().appModule(new AppModule(this)).build();\n   }\n\n   public static AppComponent getAppComponent() {\n       MyApp app = getApplication();\n       if (app.appComponent == null) {\n           app.createAppComponent();\n       }\n       return app.appComponent;\n   }\n  \n\n\nWith this, at least the application class should be able to get its fields injected, but our Activities, Fragments, Broadcast Receivers, and Services still won’t. For that, we need to call inject(this) in those too. That’s why we have that static getAppComponent() method. So we simply call this in the onCreate method of all those classes (yes, fragments too because we might need to use those fields in onStart).\n\nMyApp.getAppComponent().inject(this);\n\n\nOptimizations\n\nSo this works, but it creates a lot of factory classes for us. Turns out, class loading is pretty slow on Android and the system needs to do that every time the app has been destroyed and launched again. That means cold launch time, while slightly better than RoboGuice can still be improved. That, I will cover in the next part. Until then, you can watch this video about Dagger 2.12 optimizations.\n",
      "categories": [],
      "tags": ["android","roboguice","dagger"],
      
      "collection": "posts",
      "url": "/switching-from-roboguice-to-dagger-2/"
    },{
      "image": {"path":"/assets/img/jetpack-compose-hero.svg"},
      "title": "Intro to Jetpack Compose Navigation",
      "date": "2020-10-19 12:10:40 +0000",
      
      "content": "Update: This article was written before compose-navigation reached alpha01 and has been not updated since to reflect the changes in alpha01.\n\nUpdate 2: I strongly recommend following the official Jetpack Compose Navigation codelab instead of following this article.\n\nLast year, the Android team at Google announced Jetpack Compose. Since then, it has been seeing lots of updates; dev releases, and starting a few months ago, alpha releases with lots of great samples. Many of the sample apps implemented their own Navigation logic and many people wondered, what will be the official way to deal with navigation within Jetpack Compose, until now (or soon enough). The Jetpack Navigation library is about to reach its first release 🙌🏽\n\n\n  This is Part 1 of a 2-part article about Jetpack Compose Navigation. Click here for Part 2.\n\n\n\n\nFigure 1 - Jetpack Compose Navigation alpha release is coming soon!\n\n\n  Why should I use this?\n  Getting Started\n  Creating a simple Nav Graph    \n      Navigating within the NavGraph\n      The Result\n      What about the backstack?\n      Can I provide arguments for the destination?\n      Do I need to do anything to survive process death?\n    \n  \n  How can I update the TopAppBar title?    \n      Why is there a number in the TopAppBar?\n      The Result\n    \n  \n  GitHub repository\n  Conclusion\n\n\nWhy should I use this?\n\nBesides being the official solution, the Jetpack Navigation library uses the androidx navigation library. If you like the androidx navigation library, you’ll probably feel some familiarity while using this. Of course, if your own implementation or some other library works for you, keep using it! These are all just tools to make development easier and we should use what we think is best for the job.\n\nGetting Started\n\nHow can you get your hands on this shiny piece of code and use it in your Jetpack Compose project?\n\nFrom the androidx.dev maven repository where the Android team releases snapshots!\n\n\n  \n    In your root build.gradle file, add:\n\n    allprojects {\n  repositories {\n    // .. existing repositories\n    maven { url = 'https://androidx.dev/snapshots/builds/[buildId]/artifacts/repository' }\n  }\n}\n    \n  \n  Replace [buildId] with the latest build ID from https://androidx.dev/snapshots/builds. This post uses buildId = 6916278.\n  \n    In the dependencies block of your app’s build.gradle file, add:\n\n    implementation \"androidx.navigation:navigation-compose:1.0.0-SNAPSHOT\"\n    \n  \n\n\nCreating a simple Nav Graph\n\nIt’s very simple to implement a simple hierarchical navigation where there is only one backstack and the whole application is within this backstack. First, we create our own NavController using rememberNavController(). After that, we can create a NavHost instance with two screens called Profile and Dashboard. Since we will navigate from Profile -&gt; Dashboard after this, let’s pass our navController to the Profile Composable.\n\n@Composable\nfun SimpleNav() {\n  val navController = rememberNavController()\n  NavHost(navController, startDestination = \"Profile\") { // this: NavGraphBuilder\n    composable(\"Profile\") {\n      Profile(navController)\n    }\n    composable(\"Dashboard\") {\n      Dashboard()\n    }\n  }\n}\n\n\nYou don’t have to use a String for the Composable id inside the NavGraphBuilder. You can use any type.\n\nWe’re using the NavGraphBuilder instance, provided by the NavHost Composable and the composable extension function to add destinations to the NavGraph. We have to pass the navController to any Composables that need use it.\n\nNavigating within the NavGraph\n\nLet’s add navigation from Profile → Dashboard using a Button:\n\n@Composable\nfun Profile(navController: NavController) {\n  Column(modifier = Modifier.fillMaxSize().then(Modifier.padding(8.dp))) {\n    Text(text = Screen.Profile.title)\n    Button(\n      onClick = { navController.navigate(\"Dashboard\") },\n    ) {\n      Text(\"Open Dashboard\")\n    }\n  }\n}\n\n\nThe Result\n\nSimple Nav code on GitHub\n\n\n    \n    \n\n\nFigure 2 - Simple navigation with config changes and process death\n\nWhat about the backstack?\n\nAll of that is automatically handled already through the androidx Navigation library that this library uses. When your user presses the back button on the Dashboard screen, they’re going to be taken to the Profile screen.\n\nCan I provide arguments for the destination?\n\nAbsolutely! Instead of calling navigate(\"Dashboard\"), just pass a bundle of arguments like this:\n\nnavController.navigate(\"Dashboard\", bundleOf(\"title\" to \"My Dashboard Title\"))\n\n\nThen, in our NavGraphBuilder, we can access these arguments through backStackEntry and pass them on to the Composable.\n\n@Composable\nfun SimpleNav() {\n  val navController = rememberNavController()\n  NavHost(navController, startDestination = \"Profile\") { // this: NavGraphBuilder\n    // .. other composables\n    composable(\"Dashboard\") { backStackEntry -&gt;\n      Dashboard(\n        title = backStackEntry.arguments?.get(\"title\") as String\n      )\n    }\n  }\n}\n\n\nFigure 3 - NavArgs support coming soon!\n\nDo I need to do anything to survive process death?\n\nNot at all! As the video shows, process death support comes built-in and we don’t need to do anything further for simple hierarchies. However, as we will see in the BottomNavigation example in part 2, there are some caveats when we need to manually save and restore the NavHost state.\n\nHow can I update the TopAppBar title?\n\nnavController.currentBackStackEntryAsState() allows us to observe the state of the current backstack entry, so when we use it to set the title of TopAppBar, it will automatically update when the current backstack entry changes. Here’s what that looks like in code:\n\n@Composable\nprivate fun FunComposeApp() {\n  val navController = rememberNavController()\n  val currentScreen by navController.currentBackStackEntryAsState()\n\n  Scaffold(\n    topBar = {\n      TopAppBar(\n        title = {\n          Text(currentScreen?.destination?.id.toString())\n        }\n      )\n    },\n    bodyContent = {\n      NavHost(\n        navController = navController,\n        startDestination = \"Profile\"\n      ) { // this: NavGraphBuilder\n        composable(\"Profile\") {\n          Profile(navController)\n        }\n        composable(\"Dashboard\") {\n          Dashboard()\n        }\n      }\n    }\n  )\n}\n\n\nHere’s how it looks like on the device:\n\n\n    \n    \n\n\nFigure 4 - Basic Navigation with TopAppBar but wrong title\n\nWhy is there a number in the TopAppBar?\n\nThat is because currentScreen?.destination?.id.toString() doesn’t actually return the destinationId that we provide to navController.navigate(). Internally, the navigate() function uses the hashCode of that string + an initial ID of 0x00010000.\n\nWe’ll use this ID to determine which screen is being displayed, then use that to set the title. Let’s define our screens now:\n\nsealed class Screen(val title: String) {\n  object Profile : Screen(\"Profile\")\n  object Dashboard : Screen(\"Dashboard\")\n\n/**\n * hack to generate the same Destination ID that\n * the Compose Navigation lib generates\n **/\n  val id: Int\n    get() {\n      return title.hashCode() + 0x00010000\n    }\n}\n\nfun NavDestination.toScreen(): Screen {\n  return when (id) {\n    Screen.Profile.id -&gt; Screen.Profile\n    Screen.Dashboard.id -&gt; Screen.Dashboard\n    else -&gt; Screen.Profile\n  }\n}\n\n\nNow, let’s get the screen title from the NavDestination by using this in our TopAppBar title instead:\n\nTopAppBar(\n  title = {\n    Text(current?.destination?.toScreen()?.title ?: \"\")\n  }\n)\n\n\nThe Result\n\nBasic Nav with a TopAppBar code on GitHub\n\n\n    \n    \n\n\nFigure 5 - Basic Navigation with TopAppBar with the correct title\n\nGitHub repository\n\nAll of the code discussed in this blog post is available here:\n\nhttps://github.com/AfzalivE/Fun-Compose\n\nConclusion\n\nI think Jetpack Navigation is going to simplify navigation code for a lot of people. Like all things in Compose, it is simple to use in most cases. In part 2, we’re going to create multiple navigation graphs in a Bottom Navigation-based UI.\n\nFound this article interesting, or better yet, found a bug in the article? Please comment and let me know!\n\nThanks to the Compose Navigation samples by the Androidx Team, and thanks to Neal Manaktola for reviewing this article.\n",
      "categories": [],
      "tags": ["android","jetpack-compose","ui"],
      
      "collection": "posts",
      "url": "/intro-to-jetpack-compose-navigation/"
    },{
      "image": {"path":"/assets/img/jetpack-compose-hero.svg"},
      "title": "Multiple NavGraphs with Compose Navigation",
      "date": "2020-10-19 12:10:40 +0000",
      
      "content": "Update: This article was written before compose-navigation reached alpha01 and has been not updated since to reflect the changes in alpha01.\n\nUpdate 2: I strongly recommend following the official Jetpack Compose Navigation codelab instead of following this article.\n\nIn part 1, I wrote about how to get started with the Jetpack Compose Navigation library. I discussed how to create a simple navigation graph and how to obtain information about the graph outside it. Now, let’s explore how we can use multiple navigation graphs in a Bottom Navigation-driven UI.\n\n\n  Setup instructions\n  BottomNavigation    \n      Implementation\n      Back button doesn’t seem to work properly\n      Dashboard’s backstack gets cleared on switching tabs\n      It’s not surviving process death anymore!\n      Multiple NavGraphs within BottomNavigation\n      The Result\n    \n  \n  GitHub repository\n  Conclusion\n\n\nSetup instructions\n\nFor instructions on how to setup your project to import the Jetpack Compose Navigation library, please refer to part 1 of this series.\n\nBottomNavigation\n\nLet’s explore a scenario where we use BottomNavigation in our app but we have one tab inside which we need hierarchical navigation. Google’s Clock app does this for the Timer tab.\n\nImplementation\n\nLet’s create a Composable that shows a screen based on which tab is selected:\n\n@Composable\nfun TabContent(screen: Screen) {\n  when (screen) {\n    Screen.Profile -&gt; ProfileTab()\n    Screen.Dashboard -&gt; DashboardTab()\n    Screen.Phrases -&gt; Phrases()\n    else -&gt; ProfileTab()\n  }\n}\n\n@Composable\nfun DashboardTab() {\n  val navController = rememberNavController()\n\n  NavHost(\n    navController = navController,\n    startDestination = \"Dashboard\"\n  ) {\n    composable(\"Dashboard\") {\n        Dashboard(navController)\n    }\n    composable(\"DashboardDetail\") {\n        Text(\"Some Dashboard detail\")\n    }\n  }\n}\n\n\nWe pass the selected screen to this Composable, it shows it. Our Dashboard tab has changed though. That’s the tab we need navigation inside, DashboardTab just creates a NavHost and defines a NavGraph. Dashboard now has a Button that navigates to the DashboardDetail screen when clicked. We’ve also add it to the previously defined Screen sealed class.\n\n\n    \n    \n\n\nFigure 1 - Bottom Navigation with back press issue\n\nThat looks good, right? Looks like there are a few issues though.\n\nBack button doesn’t seem to work properly\n\nIt seems that back button taps get intercepted by the NavHostController even if we leave the tab containing the NavHost (i.e. the Dashboard Screen). I’m not sure why this is happening and it looks like a bug but I could be wrong. I have to confirm this before I file a bug.\n\nIn the meantime, I have found that disabling the NavHostController’s OnBackPressed functionality in onDispose seems to fix this. When DashboardTab is recomposed, this resets back to true.\n\n@Composable\nfun DashboardTab() {\n  // ... existing code\n\n  onDispose {\n    // workaround for issue where back press is intercepted\n    // outside this tab, even after this Composable is disposed\n    navController.enableOnBackPressed(false)\n  }\n}\n\n\nWorks properly now! Pressing the back button closes the app now instead of doing nothing.\n\n\n    \n    \n\n\nFigure 2 - Bottom Navigation with back press issue fixed\n\nDashboard’s backstack gets cleared on switching tabs\n\nWe can see in figure 1 that Dashboard screen’s backstack gets cleared when we switch tabs away from it. This is the default behaviour but it’s easy to save and restore the backstack state. Let’s create a MutableState to hold the navigation state and pass it to DashboardTab:\n\n@Composable\nfun TabContent(screen: Screen) {\n  val navState = remember { mutableStateOf(Bundle()) }\n  when (screen) {\n    Screen.Dashboard -&gt; DashboardTab(navState)\n    // .. other screens\n  }\n}\n\n@Composable\nfun DashboardTab(navState: MutableState&lt;Bundle&gt;) {\n  val navController = rememberNavController()\n\n  onCommit {\n    navController.addOnDestinationChangedListener { navController, _, _ -&gt;\n      navState.value = navController.saveState() ?: Bundle()\n    }\n    navController.restoreState(navState.value)\n\n    onDispose {\n      navController.removeOnDestinationChangedListener(callback)\n      // workaround for issue where back press is intercepted\n      // outside this tab, even after this Composable is disposed\n      navController.enableOnBackPressed(false)\n    }\n  }\n\n  // .. NavHost stuff\n}\n\n\nNavHostController provides us the saveState() and the restoreState(Bundle) functions to manually handle the state of the backstack. On every destination change, we save the state to  navState and every time DashboardTab gets recomposed, we restore its state from navState. We keep this navState in TabContent so it survives even when DashboardTab is disposed. We also remove the OnDestinationChangedListener from the navController when this Composable is disposed to avoid creating unnecessary listeners on every recomposition.\n\nOkay, this is working now. We’re able to keep Dashboard screen’s backstack, even as we switch away and return to it!\n\n\n    \n    \n\n\nFigure 3 - Bottom Navigation with backstack restoration\n\nIt’s not surviving process death anymore!\n\nOne downside of manually handling the backstack state is that we lose NavHostController’s built-in ability to survive process death. Let’s add this ability back:\n\n@Composable\nfun TabContent(screen: Screen) {\n  val navState = rememberSavedInstanceState(saver = NavStateSaver()) { mutableStateOf(Bundle()) }\n  // .. show screen\n}\n\nfun NavStateSaver(): Saver&lt;MutableState&lt;Bundle&gt;, out Any&gt; = Saver(\n  save = { it.value },\n  restore = { mutableStateOf(it) }\n)\n\n\nrememberSavedInstanceState allows us to persist and restore mutable data beyond process death. It uses a Saver object to handle the save and restore operations. Since our navState is just a MutableState&lt;Bundle&gt;, for saving, we just get the value: Bundle from it. For restoring, we recreate the MutableState object from that Bundle.\n\nThe backstack state will now persist across process death.\n\nThe currently selected screen in TabContent doesn’t survive process death. The code on GitHub shows how to do this as well.\n\nBottom Navigation code on GitHub\n\nMultiple NavGraphs within BottomNavigation\n\nWhat if we want to keep multiple backstacks, within multiple tabs? Actually, it’s not very different from keeping one NavGraph. Let’s create a Phrases screen to have its own backstack. It will navigate to a new screen called PhraseDetail.\n\n@Composable\nfun TabContent(screen: Screen) {\n  val dashboardNavState = rememberSavedInstanceState(saver = NavStateSaver()) { mutableStateOf(Bundle()) }\n  val phrasesNavState = rememberSavedInstanceState(saver = NavStateSaver()) { mutableStateOf(Bundle()) }\n  when (screen) {\n    Screen.Dashboard -&gt; DashboardTab(dashboardNavState)\n    Screen.Phrases -&gt; PhrasesTab(phrasesNavState)\n    // .. other screens\n  }\n}\n\n@Composable\nfun PhrasesTab(navState: MutableState&lt;Bundle&gt;) {\n  val navController = rememberNavController()\n\n  onCommit {\n    val callback = NavController.OnDestinationChangedListener { navController, _, _ -&gt;\n      navState.value = navController.saveState() ?: Bundle()\n    }\n    navController.addOnDestinationChangedListener(callback)\n    navController.restoreState(navState.value)\n    onDispose {\n      navController.removeOnDestinationChangedListener(callback)\n      // workaround for issue where back press is intercepted\n      // outside this tab, even after this Composable is disposed\n      navController.enableOnBackPressed(false)\n    }\n  }\n\n  NavHost(\n    navController = navController,\n    startDestination = \"Phrases\"\n  ) {\n    composable(\"Phrases\") {\n        Phrases(navController)\n    }\n    composable(\"PhraseDetail\") {\n        PhraseDetail()\n    }\n  }\n}\n\n\nPhrasesTab ends up looking very similar to DashboardTab. At this point, we could probably create a RestorableNavHost that just contains this functionality, takes a MutableState&lt;Bundle&gt; and a NavGraphBuilder function.\n\nThe Result\n\n\n    \n    \n\n\nFigure 4 - Bottom Navigation with multiple Nav Graphs\n\nGitHub repository\n\nAll of the code discussed in this blog post is available here:\n\nMultiple Nav Graphs code on GitHub\n\nConclusion\n\nWhile it was still relatively simple to achieve this, there were a few things we had to be careful of. Since this is pre-alpha/alpha stage, I’m sure some (if not all) of the issues mentioned here will be addressed by the time this is production ready. I’m really excited for Compose and how it shapes the future of Android development and the quality of apps that we will be able to create.\n\nFound this article interesting, or better yet, found a bug in the article? Please comment and let me know!\n\nThanks to the Compose Navigation samples by the Androidx Team, and thanks to Neal Manaktola for reviewing this article.\n",
      "categories": [],
      "tags": ["android","jetpack-compose","ui"],
      
      "collection": "posts",
      "url": "/multiple-navigation-graphs-with-jetpack-compose-navigation/"
    },{
      
      "title": "Android Studio",
      "date": "2024-03-15 15:16:30 +0000",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-android-studio/"
    },{
      
      "title": "Android",
      "date": "2024-03-15 15:16:30 +0000",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-android/"
    },{
      
      "title": "Dagger",
      "date": "2024-03-15 15:16:30 +0000",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-dagger/"
    },{
      
      "title": "Jetpack Compose",
      "date": "2024-03-15 15:16:30 +0000",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-jetpack-compose/"
    },{
      
      "title": "RoboGuice",
      "date": "2024-03-15 15:16:30 +0000",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-roboguice/"
    },{
      
      "title": "UI",
      "date": "2024-03-15 15:16:30 +0000",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-ui/"
    }
  ]
}

